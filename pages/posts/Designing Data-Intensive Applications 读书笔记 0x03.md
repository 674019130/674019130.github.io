---
title: 《Designing Data-Intensive Applications》 读书笔记 | 0x03
# date: 2024-05-02 02:28:12
tags: [DDIA, 读书笔记, 数据密集型应用]
categories: [技术笔记, 分布式系统]
excerpt: 数据传输和数据应用如何一起拥抱变化呢？
author: 苏
readmore: true
toc: true
---

> 唯变所适
>
> —— 以弗所的赫拉克利特，为柏拉图所引（公元前 360 年）

---

> #### 远程过程调用（RPC）的问题
>
> Web 服务仅仅是通过网络进行 API 请求的一系列技术的最新版本，其中许多技术受到了大量的炒作，但是存在严重的问题。Enterprise JavaBeans（EJB）和 Java 的 **远程方法调用（RMI）** 仅限于 Java。**分布式组件对象模型（DCOM）** 仅限于 Microsoft 平台。**公共对象请求代理体系结构（CORBA）** 过于复杂，不提供向后或向前兼容性【41】。
>
> 所有这些都是基于 **远程过程调用（RPC）** 的思想，该过程调用自 20 世纪 70 年代以来一直存在【42】。RPC 模型试图向远程网络服务发出请求，看起来与在同一进程中调用编程语言中的函数或方法相同（这种抽象称为位置透明）。尽管 RPC 起初看起来很方便，但这种方法根本上是有缺陷的【43,44】。网络请求与本地函数调用非常不同：
>
> - 本地函数调用是可预测的，并且成功或失败仅取决于受你控制的参数。网络请求是不可预测的：请求或响应可能由于网络问题会丢失，或者远程计算机可能很慢或不可用，这些问题完全不在你的控制范围之内。网络问题很常见，因此必须有所准备，例如重试失败的请求。
> - 本地函数调用要么返回结果，要么抛出异常，或者永远不返回（因为进入无限循环或进程崩溃）。网络请求有另一个可能的结果：由于超时，它返回时可能没有结果。在这种情况下，你根本不知道发生了什么：如果你没有得到来自远程服务的响应，你无法知道请求是否通过（我们将在 [第八章] 更详细地讨论这个问题）。
> - 如果你重试失败的网络请求，可能会发生请求实际上已经完成，只是响应丢失的情况。在这种情况下，重试将导致该操作被执行多次，除非你在协议中建立数据去重机制（**幂等性**，即 idempotence）。本地函数调用时没有这样的问题。（在 [第十一章] 更详细地讨论幂等性）
> - 每次调用本地函数时，通常需要大致相同的时间来执行。网络请求比函数调用要慢得多，而且其延迟也是非常可变的：好的时候它可能会在不到一毫秒的时间内完成，但是当网络拥塞或者远程服务超载时，可能需要几秒钟的时间才能完成相同的操作。
> - 调用本地函数时，可以高效地将引用（指针）传递给本地内存中的对象。当你发出一个网络请求时，所有这些参数都需要被编码成可以通过网络发送的一系列字节。如果参数是像数字或字符串这样的基本类型倒是没关系，但是对于较大的对象很快就会出现问题。
> - 客户端和服务可以用不同的编程语言实现，所以 RPC 框架必须将数据类型从一种语言翻译成另一种语言。这可能会变得很丑陋，因为不是所有的语言都具有相同的类型 —— 例如回想一下 JavaScript 的数字大于 $2^{53}$ 的问题（请参阅 "\[JSON、XML 和二进制变体\]"）。用单一语言编写的单个进程中不存在此问题。
>
> 所有这些因素意味着尝试使远程服务看起来像编程语言中的本地对象一样毫无意义，因为这是一个根本不同的事情。REST 的部分吸引力在于，它并不试图隐藏它是一个网络协议的事实（尽管这似乎并没有阻止人们在 REST 之上构建 RPC 库）。

总体来说问题是因为由于「**网络问题**」因素的增加，导致 RPC 调用存在不可控的问题。

重点强调了 **幂等性**（idempotence）和较大对象的传输问题。

强调了语言之间翻译可能导致的「丑陋」。

---

> 对于可演化性，重要的是可以独立更改和部署 RPC 客户端和服务器。与通过数据库流动的数据相比（如上一节所述），我们可以在通过服务进行数据流的情况下做一个简化的假设：**假定所有的服务器都会先更新，其次是所有的客户端。**因此，你只需要在请求上具有向后兼容性，并且对响应具有向前兼容性。

**对请求具有向后兼容性，可以使更新前后的服务器都能应对客户端的请求；对响应具有向前兼容性，可以使尚未迭代的客户端应对已更新的服务器的响应。**

---

> RESTful API 通常使用 JSON（没有正式指定的模式）用于响应，以及用于请求的 JSON 或 URI 编码 / 表单编码的请求参数。添加可选的请求参数并向响应对象添加新的字段通常被认为是保持兼容性的改变。

JSON 有时候确实还挺好用的。

---

**You**：

> REST 和 RPC的数据传输方式有什么区别

**ChatGPT**：

> REST（Representational State Transfer）和 RPC（Remote Procedure Call）是两种不同的通信模式，它们在数据传输方式上有一些区别。
>
> 1. **REST（Representational State Transfer）：**
>    - REST 是一种基于网络的软件架构风格，它使用标准的 HTTP 协议进行通信。
>    - 在 REST 中，资源以 URL 的形式暴露，通过 HTTP 方法（如 GET、POST、PUT、DELETE）对资源进行操作。
>    - REST 的通信是无状态的，即每个请求都包含足够的信息来处理该请求，服务器不需要保存客户端的状态信息。
>    - REST 通常使用 JSON 或 XML 格式来传输数据。
> 2. **RPC（Remote Procedure Call）：**
>    - RPC 是一种远程过程调用的机制，允许一个程序在另一个地址空间（通常在远程计算机上）上执行一个子程序。
>    - 在 RPC 中，客户端调用服务端的函数或过程，就像调用本地函数一样，但实际上是在不同的地址空间中执行。
>    - RPC 通常使用自定义协议来进行通信，通常会在底层使用 TCP 或 UDP 协议。
>
> 区别：
>
> - **协议和通信方式：** REST 使用标准的 HTTP 协议，通过 URL 对资源进行操作；而 RPC 使用自定义的协议，在客户端和服务端之间进行函数调用。
> - **语义和操作：** 在 REST 中，操作通常是面向资源的，例如 GET 获取资源、POST 创建资源等；而在 RPC 中，操作是面向函数或过程的，客户端调用服务端的函数。
> - **通信状态：** REST 是无状态的，每个请求都包含足够的信息来处理该请求；而在 RPC 中，客户端和服务端之间可能需要维护一些状态信息。
>
> 总的来说，REST 更适合于资源导向的系统设计，而 RPC 更适合于函数调用和远程服务调用。选择 REST 还是 RPC 取决于你的应用程序的需求和设计。

---

> ### 消息传递中的数据流
>
> 我们一直在研究从一个过程到另一个过程的编码数据流的不同方式。到目前为止，我们已经讨论了 REST 和 RPC（其中一个进程通过网络向另一个进程发送请求并期望尽可能快的响应）以及数据库（一个进程写入编码数据，另一个进程在将来再次读取）。
>
> 在最后一节中，我们将简要介绍一下 RPC 和数据库之间的异步消息传递系统。它们与 RPC 类似，因为客户端的请求（通常称为消息）以低延迟传送到另一个进程。它们与数据库类似，不是通过直接的网络连接发送消息，而是通过称为消息代理（也称为消息队列或面向消息的中间件）的中介来临时存储消息。
>
> 与直接 RPC 相比，使用消息代理有几个优点：
>
> - 如果收件人不可用或过载，可以充当缓冲区，从而提高系统的可靠性。
> - 它可以自动将消息重新发送到已经崩溃的进程，从而防止消息丢失。
> - 避免发件人需要知道收件人的 IP 地址和端口号（这在虚拟机经常出入的云部署中特别有用）。
> - 它允许将一条消息发送给多个收件人。
> - 将发件人与收件人逻辑分离（发件人只是发布邮件，不关心使用者）。
>
> 然而，与 RPC 相比，差异在于消息传递通信通常是单向的：发送者通常不期望收到其消息的回复。一个进程可能发送一个响应，但这通常是在一个单独的通道上完成的。这种通信模式是异步的：发送者不会等待消息被传递，而只是发送它，然后忘记它。

虽然翻译不太国内，但是我还是读出了这就是消！息！队！列！

---

> 详细的交付语义因实现和配置而异，但通常情况下，消息代理的使用方式如下：一个进程将消息发送到指定的队列或主题，代理确保将消息传递给那个队列或主题的一个或多个消费者或订阅者。在同一主题上可以有许多生产者和许多消费者。

ChatGPT：

> 这里的"交付语义"可以更清晰地表达为消息传递的可靠性保证和语义含义。可以将这部分重新表达如下：
>
> 详细的消息传递语义因不同的消息代理实现和配置而有所不同，但通常情况下，消息代理确保消息的可靠传递，并提供了不同的交付语义以满足不同的业务需求。交付语义包括以下几种常见的模式：
>
> 1. **至少一次（At Least Once）：** 消息代理保证消息至少会被传递一次给消费者，确保消息不会丢失，但可能会导致消息重复传递。
> 2. **至多一次（At Most Once）：** 消息代理保证消息最多被传递一次给消费者，确保消费者不会接收到重复的消息，但可能会导致消息丢失。
> 3. **正好一次（Exactly Once）：** 消息代理保证每条消息都会被传递且仅传递一次给消费者，既不会丢失消息，也不会导致消息重复传递，是最强的消息传递保证模式。
>
> 这些交付语义定义了消息代理在消息传递过程中的行为规范，帮助开发人员选择适当的模式以满足应用程序的需求。

---
